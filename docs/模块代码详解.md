# Go-Agent 模块代码详解

## 目录

1. [Agent 核心模块代码分析](#agent-核心模块代码分析)
2. [ADK 模块代码分析](#adk-模块代码分析)
3. [Memory 记忆系统代码分析](#memory-记忆系统代码分析)
4. [Models 模型层代码分析](#models-模型层代码分析)
5. [Tools 工具系统代码分析](#tools-工具系统代码分析)
6. [SubAgents 子智能体代码分析](#subagents-子智能体代码分析)
7. [性能优化实现细节](#性能优化实现细节)

---

## Agent 核心模块代码分析

### 文件结构

```
agent.go              # 核心 Agent 实现
agent_orchestrators.go # 工具编排逻辑
agent_tool.go         # 工具适配器
agent_checkpoint_test.go # 状态持久化测试
types.go              # 类型定义
catalog.go            # 工具和子智能体目录
```

### Agent 结构体详解

```go
type Agent struct {
    // 核心组件
    model        models.Agent           // LLM 模型接口
    memory       *memory.SessionMemory  // 会话记忆管理
    systemPrompt string                 // 系统提示词
    contextLimit int                    // 上下文记忆数量限制
    
    // 工具与子智能体管理
    toolCatalog       ToolCatalog        // 工具目录（注册与查找）
    subAgentDirectory SubAgentDirectory  // 子智能体目录
    
    // UTCP 相关
    UTCPClient        utcp.UtcpClientInterface // UTCP 客户端
    CodeMode          *codemode.CodeModeUTCP   // CodeMode 支持
    CodeChain         *chain.UtcpChainClient   // 链式调用支持
    
    // 协作与共享
    Shared    *memory.SharedSession      // 共享会话（多智能体）
    
    // 并发控制
    mu sync.Mutex                        // 保护 Agent 状态
    
    // 缓存优化
    toolMu           sync.RWMutex        // 工具缓存锁
    toolSpecsCache   []tools.Tool        // 工具规范缓存
    toolSpecsExpiry  time.Time           // 缓存过期时间
    toolPromptCache  string              // 工具提示词缓存
    toolPromptKey    string              // 缓存键
    toolPromptExpiry time.Time           // 提示词缓存过期时间
}
```

**设计要点**：
- **并发安全**：使用 `sync.Mutex` 和 `sync.RWMutex` 保护共享状态
- **性能优化**：工具规范和提示词缓存（默认 TTL 30 秒）
- **模块化**：通过接口注入依赖，支持替换实现

### New() 构造函数

```go
func New(opts Options) (*Agent, error) {
    // 1. 验证必需组件
    if opts.Model == nil {
        return nil, errors.New("agent requires a language model")
    }
    if opts.Memory == nil {
        return nil, errors.New("agent requires session memory")
    }
    
    // 2. 设置默认值
    ctxLimit := opts.ContextLimit
    if ctxLimit <= 0 {
        ctxLimit = 8  // 默认保留 8 条记忆
    }
    
    systemPrompt := opts.SystemPrompt
    if strings.TrimSpace(systemPrompt) == "" {
        systemPrompt = defaultSystemPrompt
    }
    
    // 3. 初始化工具目录（容错模式）
    toolCatalog := opts.ToolCatalog
    tolerantTools := false
    if toolCatalog == nil {
        toolCatalog = NewStaticToolCatalog(nil)
        tolerantTools = true  // 允许注册失败
    }
    for _, tool := range opts.Tools {
        if tool == nil {
            continue
        }
        if err := toolCatalog.Register(tool); err != nil {
            if tolerantTools {
                continue  // 跳过错误工具
            }
            return nil, err
        }
    }
    
    // 4. 初始化子智能体目录（同样容错）
    subAgentDirectory := opts.SubAgentDirectory
    tolerantSubAgents := false
    if subAgentDirectory == nil {
        subAgentDirectory = NewStaticSubAgentDirectory(nil)
        tolerantSubAgents = true
    }
    for _, sa := range opts.SubAgents {
        if sa == nil {
            continue
        }
        if err := subAgentDirectory.Register(sa); err != nil {
            if tolerantSubAgents {
                continue
            }
            return nil, err
        }
    }
    
    // 5. 创建 Agent 实例
    a := &Agent{
        model:             opts.Model,
        memory:            opts.Memory,
        systemPrompt:      systemPrompt,
        contextLimit:      ctxLimit,
        toolCatalog:       toolCatalog,
        subAgentDirectory: subAgentDirectory,
        UTCPClient:        opts.UTCPClient,
        Shared:            opts.Shared,
        CodeMode:          opts.CodeMode,
        CodeChain:         opts.CodeChain,
    }
    
    return a, nil
}
```

**关键设计**：
- **容错性**：自动创建默认目录，并在宽容模式下跳过无效组件
- **零值友好**：所有可选项都有合理的默认值
- **验证优先**：必需组件缺失时立即报错

### Generate() 核心对话方法

这是 Agent 最重要的方法，实现了完整的对话生成流程：

```go
func (a *Agent) Generate(ctx context.Context, sessionID, prompt string) (string, error) {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    // 步骤 1: 检索相关记忆（RAG）
    memories, err := a.retrieveRelevantMemories(ctx, sessionID, prompt)
    if err != nil {
        return "", err
    }
    
    // 步骤 2: 构建完整上下文
    fullPrompt := a.buildPromptWithMemories(sessionID, prompt, memories)
    
    // 步骤 3: 调用 LLM 生成响应
    response, err := a.model.Generate(ctx, fullPrompt)
    if err != nil {
        return "", err
    }
    
    // 步骤 4: 解析是否需要工具调用
    toolCalls := a.parseToolCalls(response)
    
    if len(toolCalls) > 0 {
        // 步骤 5: 执行工具
        toolResults := a.executeTools(ctx, sessionID, toolCalls)
        
        // 步骤 6: 将工具结果合并到上下文
        fullPrompt = a.appendToolResults(fullPrompt, toolResults)
        
        // 步骤 7: 再次调用 LLM 生成最终响应
        response, err = a.model.Generate(ctx, fullPrompt)
        if err != nil {
            return "", err
        }
    }
    
    // 步骤 8: 存储对话到记忆
    a.storeConversation(ctx, sessionID, prompt, response)
    
    return response, nil
}
```

### buildPrompt() 上下文构建

```go
func (a *Agent) buildPrompt(
    ctx context.Context,
    sessionID string,
    userInput string,
) (string, error) {
    
    // 1. 分类查询类型以优化检索策略
    queryType := classifyQuery(userInput)
    var records []memory.MemoryRecord
    var err error
    
    switch queryType {
    case QueryMath:
        // 数学问题不需要大量上下文
        records, err = a.memory.Retrieve(ctx, sessionID, userInput, 2)
        
    case QueryFactual:
        // 事实查询需要更多背景
        records, err = a.memory.Retrieve(ctx, sessionID, userInput, a.contextLimit)
        
    case QueryConversational:
        // 对话查询需要最近的上下文
        records, err = a.memory.RetrieveRecent(ctx, sessionID, a.contextLimit)
        
    default:
        // 默认策略
        records, err = a.memory.Retrieve(ctx, sessionID, userInput, a.contextLimit)
    }
    
    if err != nil {
        return "", err
    }
    
    // 2. 组装提示词
    var sb strings.Builder
    
    // 系统提示词
    sb.WriteString(a.systemPrompt)
    sb.WriteString("\n\n")
    
    // 记忆上下文
    if len(records) > 0 {
        sb.WriteString("## Relevant Context:\n")
        for i, rec := range records {
            sb.WriteString(fmt.Sprintf("%d. %s\n", i+1, rec.Content))
            if rec.Summary != "" {
                sb.WriteString(fmt.Sprintf("   (Summary: %s)\n", rec.Summary))
            }
        }
        sb.WriteString("\n")
    }
    
    // 工具定义（如果需要）
    if a.shouldIncludeTools(userInput) {
        toolPrompt := a.getToolPrompt()
        sb.WriteString(toolPrompt)
        sb.WriteString("\n\n")
    }
    
    // 用户输入
    sb.WriteString("## User Query:\n")
    sb.WriteString(userInput)
    
    return sb.String(), nil
}
```

**优化点**：
- **查询分类**：根据不同类型使用不同检索策略
- **懒加载工具**：仅在需要时包含工具定义
- **缓存利用**：工具提示词被缓存避免重复生成

### classifyQuery() 查询分类

```go
func classifyQuery(input string) QueryType {
    lower := strings.ToLower(input)
    
    // 数学表达式检测
    if containsMathOperators(lower) {
        return QueryMath
    }
    
    // 事实查询关键词
    factualKeywords := []string{
        "what is", "who is", "where is", "when did",
        "how many", "define", "explain",
    }
    for _, kw := range factualKeywords {
        if strings.Contains(lower, kw) {
            return QueryFactual
        }
    }
    
    // 对话式关键词
    conversationalKeywords := []string{
        "tell me about", "can you", "would you",
        "please", "thank you", "continue",
    }
    for _, kw := range conversationalKeywords {
        if strings.Contains(lower, kw) {
            return QueryConversational
        }
    }
    
    return QueryGeneral
}
```

### 工具调用编排

#### 工具规范缓存

```go
func (a *Agent) ToolSpecs() []tools.Tool {
    a.toolMu.RLock()
    
    // 检查缓存是否有效
    if time.Now().Before(a.toolSpecsExpiry) && a.toolSpecsCache != nil {
        cached := a.toolSpecsCache
        a.toolMu.RUnlock()
        return cached
    }
    a.toolMu.RUnlock()
    
    // 重新生成
    a.toolMu.Lock()
    defer a.toolMu.Unlock()
    
    // 双重检查（并发安全）
    if time.Now().Before(a.toolSpecsExpiry) && a.toolSpecsCache != nil {
        return a.toolSpecsCache
    }
    
    specs := a.toolCatalog.Specs()
    utcpTools := convertToUTCPTools(specs)
    
    // 更新缓存
    a.toolSpecsCache = utcpTools
    a.toolSpecsExpiry = time.Now().Add(defaultToolCacheTTL)
    
    return utcpTools
}
```

**性能优化**：
- 30 秒缓存 TTL 避免频繁序列化
- 双重检查锁定模式（Double-Checked Locking）
- 读写锁分离提高并发性能

#### executeTool() 工具执行

```go
func (a *Agent) executeTool(
    ctx context.Context,
    sessionID, toolName string,
    args map[string]any,
) (any, error) {
    
    if args == nil {
        args = map[string]any{}
    }
    
    // 1. 尝试 UTCP 远程工具
    if a.UTCPClient != nil {
        // 检查是否为流式调用
        if streamFlag, ok := args["stream"].(bool); ok && streamFlag {
            stream, err := a.UTCPClient.CallToolStream(ctx, toolName, args)
            if err != nil {
                return nil, err
            }
            
            // 累积流式块
            var sb strings.Builder
            for {
                chunk, err := stream.Next()
                if err != nil {
                    break  // EOF 或错误
                }
                if chunk != nil {
                    sb.WriteString(fmt.Sprint(chunk))
                }
            }
            return sb.String(), nil
        }
        
        // 非流式远程调用
        return a.UTCPClient.CallTool(ctx, toolName, args)
    }
    
    // 2. 本地工具查找
    tool, _, found := a.toolCatalog.Lookup(toolName)
    if found {
        req := ToolRequest{
            SessionID: sessionID,
            Arguments: args,
        }
        resp, err := tool.Invoke(ctx, req)
        if err != nil {
            return nil, err
        }
        return resp.Content, nil
    }
    
    // 3. 子智能体委派
    subAgent, found := a.subAgentDirectory.Lookup(toolName)
    if found {
        instruction, _ := args["instruction"].(string)
        return subAgent.Run(ctx, instruction)
    }
    
    return nil, fmt.Errorf("unknown tool: %s", toolName)
}
```

**设计亮点**：
- **统一接口**：工具、远程工具、子智能体使用相同调用方式
- **流式支持**：自动处理流式和非流式调用
- **优先级**：UTCP > 本地工具 > 子智能体

### Checkpoint 与 Restore

#### Checkpoint 实现

```go
func (a *Agent) Checkpoint() ([]byte, error) {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    // 导出状态
    state := AgentState{
        SystemPrompt: a.systemPrompt,
        ShortTerm:    a.memory.ExportShortTerm(),  // 短期记忆
        Timestamp:    time.Now(),
    }
    
    // 包含共享空间成员关系
    if a.Shared != nil {
        state.JoinedSpaces = a.Shared.ExportJoinedSpaces()
    }
    
    // 序列化为 JSON
    return json.Marshal(state)
}
```

#### Restore 实现

```go
func (a *Agent) Restore(data []byte) error {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    var state AgentState
    if err := json.Unmarshal(data, &state); err != nil {
        return err
    }
    
    // 恢复系统提示词
    a.systemPrompt = state.SystemPrompt
    
    // 恢复短期记忆
    a.memory.ImportShortTerm(state.ShortTerm)
    
    // 恢复共享空间成员关系
    if a.Shared != nil && len(state.JoinedSpaces) > 0 {
        a.Shared.ImportJoinedSpaces(state.JoinedSpaces)
    }
    
    return nil
}
```

**应用场景**：
```go
// 保存到文件
data, _ := agent.Checkpoint()
os.WriteFile("agent-state.json", data, 0644)

// 跨服务器迁移
redisClient.Set("agent:123:state", data, 24*time.Hour)

// 恢复
data, _ := os.ReadFile("agent-state.json")
newAgent.Restore(data)
```

---

## ADK 模块代码分析

### AgentDevelopmentKit 结构

```go
type AgentDevelopmentKit struct {
    mu sync.RWMutex
    
    // 模块管理
    modules      []Module     // 注册的模块列表
    bootstrapped bool         // 是否已初始化
    
    // Provider 注册表
    modelProvider    ModelProvider       // 模型提供者
    memoryProvider   MemoryProvider      // 记忆提供者
    toolProviders    []ToolProvider      // 工具提供者
    subAgentProvider []SubAgentProvider  // 子智能体提供者
    
    // 默认配置
    defaultSystemPrompt string
    defaultContextLimit int
    
    // 运行时组件
    agentOptions []AgentOption
    UTCP         utcp.UtcpClientInterface
    CodeMode     *codemode.CodeModeUTCP
    ChainMode    *chain.UtcpChainClient
}
```

### Bootstrap 流程

```go
func (k *AgentDevelopmentKit) Bootstrap(ctx context.Context) error {
    k.mu.Lock()
    
    // 幂等性检查
    if k.bootstrapped {
        k.mu.Unlock()
        return nil
    }
    
    // 复制模块列表（避免在遍历时修改）
    modules := append([]Module(nil), k.modules...)
    k.mu.Unlock()
    
    // 按顺序执行模块
    for _, module := range modules {
        if module == nil {
            continue
        }
        
        if err := module.Provision(ctx, k); err != nil {
            name := "<unnamed module>"
            if module.Name() != "" {
                name = module.Name()
            }
            return fmt.Errorf("kit module %s: %w", name, err)
        }
    }
    
    // 标记为已初始化
    k.mu.Lock()
    k.bootstrapped = true
    k.mu.Unlock()
    
    return nil
}
```

**设计特点**：
- **幂等性**：多次调用 Bootstrap 是安全的
- **顺序执行**：模块按注册顺序初始化
- **错误上下文**：包含模块名称的清晰错误信息

### BuildAgent 构建流程

```go
func (k *AgentDevelopmentKit) BuildAgent(ctx context.Context) (*agent.Agent, error) {
    k.mu.RLock()
    
    // 检查是否已初始化
    if !k.bootstrapped {
        k.mu.RUnlock()
        return nil, errors.New("kit not bootstrapped")
    }
    
    modelProv := k.modelProvider
    memProv := k.memoryProvider
    toolProvs := append([]ToolProvider(nil), k.toolProviders...)
    subProvs := append([]SubAgentProvider(nil), k.subAgentProvider...)
    opts := append([]AgentOption(nil), k.agentOptions...)
    k.mu.RUnlock()
    
    // 1. 创建模型
    if modelProv == nil {
        return nil, errors.New("no model provider registered")
    }
    model, err := modelProv(ctx)
    if err != nil {
        return nil, fmt.Errorf("model provider: %w", err)
    }
    
    // 2. 创建记忆
    if memProv == nil {
        return nil, errors.New("no memory provider registered")
    }
    mem, err := memProv(ctx)
    if err != nil {
        return nil, fmt.Errorf("memory provider: %w", err)
    }
    
    // 3. 收集工具
    var tools []agent.Tool
    for _, tp := range toolProvs {
        t, err := tp(ctx)
        if err != nil {
            return nil, err
        }
        tools = append(tools, t...)
    }
    
    // 4. 收集子智能体
    var subAgents []agent.SubAgent
    for _, sp := range subProvs {
        sa, err := sp(ctx)
        if err != nil {
            return nil, err
        }
        subAgents = append(subAgents, sa...)
    }
    
    // 5. 构建 Agent 选项
    agentOpts := agent.Options{
        Model:        model,
        Memory:       mem,
        SystemPrompt: k.defaultSystemPrompt,
        ContextLimit: k.defaultContextLimit,
        Tools:        tools,
        SubAgents:    subAgents,
        UTCPClient:   k.UTCP,
        CodeMode:     k.CodeMode,
        CodeChain:    k.ChainMode,
    }
    
    // 6. 应用自定义选项
    for _, opt := range opts {
        opt(&agentOpts)
    }
    
    // 7. 创建 Agent
    return agent.New(agentOpts)
}
```

### Module 示例：ModelModule

```go
type modelModule struct {
    name    string
    factory ModelProvider
}

func (m *modelModule) Name() string {
    return m.name
}

func (m *modelModule) Provision(ctx context.Context, kit *AgentDevelopmentKit) error {
    // 注册模型提供者
    kit.UseModelProvider(m.factory)
    return nil
}

// 使用示例
func NewModelModule(name string, factory ModelProvider) Module {
    return &modelModule{
        name:    name,
        factory: factory,
    }
}
```

### Module 示例：MemoryModule

```go
type memoryModule struct {
    name           string
    maxTokens      int
    vectorStore    memory.VectorStore
    embedder       memory.Embedder
    engineOptions  *memory.Options
}

func (m *memoryModule) Name() string {
    return m.name
}

func (m *memoryModule) Provision(ctx context.Context, kit *AgentDevelopmentKit) error {
    // 创建记忆引擎
    engine := memory.NewEngine(m.vectorStore, *m.engineOptions)
    engine.WithEmbedder(m.embedder)
    
    // 创建记忆库
    bank := memory.NewMemoryBankWithStore(m.vectorStore, engine)
    
    // 注册记忆提供者
    kit.UseMemoryProvider(func(ctx context.Context) (*memory.SessionMemory, error) {
        return memory.NewSessionMemory(bank), nil
    })
    
    return nil
}

// 便捷构造函数
func InMemoryMemory(maxTokens int, embedder memory.Embedder) Module {
    store := memory.NewInMemoryStore()
    opts := memory.DefaultOptions()
    
    return &memoryModule{
        name:          "in-memory-module",
        maxTokens:     maxTokens,
        vectorStore:   store,
        embedder:      embedder,
        engineOptions: &opts,
    }
}
```

---

## Memory 记忆系统代码分析

### Engine 核心算法

#### importanceScore() 重要性评分

```go
func importanceScore(content string, metadata map[string]any) float64 {
    score := 0.5  // 基础分
    
    // 1. 长度因子（更长的内容可能更重要）
    length := utf8.RuneCountInString(content)
    if length > 200 {
        score += 0.2
    } else if length > 50 {
        score += 0.1
    }
    
    // 2. 实体密度（命名实体越多越重要）
    entities := countNamedEntities(content)
    entityDensity := float64(entities) / float64(max(length, 1))
    score += min(entityDensity * 0.3, 0.3)
    
    // 3. 关键词匹配
    keywords := []string{
        "important", "critical", "urgent", "remember",
        "key", "crucial", "significant",
    }
    lower := strings.ToLower(content)
    for _, kw := range keywords {
        if strings.Contains(lower, kw) {
            score += 0.1
            break
        }
    }
    
    // 4. 元数据标记
    if imp, ok := metadata["importance"].(float64); ok {
        return imp  // 显式指定的重要性
    }
    
    // 5. 来源权重
    if source, ok := metadata["source"].(string); ok {
        switch source {
        case "user_explicit":
            score += 0.3
        case "system":
            score += 0.2
        }
    }
    
    return min(score, 1.0)
}
```

#### recencyScore() 时间衰减

```go
func recencyScore(age time.Duration, halfLife time.Duration) float64 {
    if halfLife <= 0 {
        halfLife = 7 * 24 * time.Hour  // 默认 7 天半衰期
    }
    
    // 指数衰减: score = e^(-λt)
    // 其中 λ = ln(2) / halfLife
    lambda := math.Log(2) / halfLife.Hours()
    ageHours := age.Hours()
    
    return math.Exp(-lambda * ageHours)
}
```

**半衰期示例**：
- 7 天半衰期：7 天后权重降为 0.5
- 14 天后权重降为 0.25
- 28 天后权重降为 0.0625

#### mmrSelect() MMR 去重算法

```go
// Maximum Marginal Relevance
func mmrSelect(
    candidates []model.MemoryRecord,
    queryEmbedding []float32,
    limit int,
    lambda float64,  // 相关性 vs 多样性平衡（0.5 = 均衡）
) []model.MemoryRecord {
    
    if len(candidates) <= limit {
        return candidates
    }
    
    selected := make([]model.MemoryRecord, 0, limit)
    remaining := append([]model.MemoryRecord(nil), candidates...)
    
    for len(selected) < limit && len(remaining) > 0 {
        var bestIdx int
        var bestScore float64
        
        for i, candidate := range remaining {
            // 相关性分数
            relevance := model.CosineSimilarity(queryEmbedding, candidate.Embedding)
            
            // 多样性惩罚（与已选项的最大相似度）
            maxSim := 0.0
            for _, sel := range selected {
                sim := model.CosineSimilarity(candidate.Embedding, sel.Embedding)
                if sim > maxSim {
                    maxSim = sim
                }
            }
            
            // MMR 得分
            mmrScore := lambda*relevance - (1-lambda)*maxSim
            
            if mmrScore > bestScore || i == 0 {
                bestScore = mmrScore
                bestIdx = i
            }
        }
        
        // 移动到已选集合
        selected = append(selected, remaining[bestIdx])
        remaining = append(remaining[:bestIdx], remaining[bestIdx+1:]...)
    }
    
    return selected
}
```

**参数说明**：
- `lambda = 1.0`: 仅考虑相关性（可能有冗余）
- `lambda = 0.0`: 仅考虑多样性（可能不相关）
- `lambda = 0.5`: 均衡相关性与多样性（推荐）

#### Retrieve() 综合检索

```go
func (e *Engine) Retrieve(
    ctx context.Context,
    sessionID, query string,
    limit int,
) ([]model.MemoryRecord, error) {
    
    // 1. 嵌入查询
    embedding, err := e.embed(ctx, query)
    if err != nil {
        return nil, err
    }
    
    // 2. 提取关键词（用于辅助评分）
    keywords := extractKeywords(query)
    
    // 3. 向量检索（扩大候选集）
    searchLimit := limit * 4  // 过采样
    candidates, err := e.store.SearchMemory(ctx, sessionID, embedding, searchLimit)
    if err != nil {
        return nil, err
    }
    
    // 4. 图邻域扩展（如果支持）
    if graphStore, ok := e.store.(store.GraphStore); ok {
        neighbors := e.expandGraphNeighborhood(ctx, candidates)
        candidates = append(candidates, neighbors...)
    }
    
    // 5. 综合评分
    weights := e.opts.normalizedWeights()
    now := e.clock().UTC()
    
    for i := range candidates {
        rec := &candidates[i]
        
        // 5.1 语义相似度
        rec.Score = model.CosineSimilarity(embedding, rec.Embedding)
        
        // 5.2 关键词匹配
        rec.KeywordScore = keywordMatchScore(rec.Content, keywords)
        
        // 5.3 时间衰减
        recency := recencyScore(now.Sub(rec.CreatedAt), e.opts.HalfLife)
        
        // 5.4 综合权重
        rec.WeightedScore = 
            weights.Similarity * rec.Score +
            weights.Keywords * rec.KeywordScore +
            weights.Importance * rec.Importance +
            weights.Recency * recency
    }
    
    // 6. MMR 去重与多样化
    selected := mmrSelect(candidates, embedding, limit, e.opts.LambdaMMR)
    
    // 7. 重排序（重要性 > 综合得分 > 时间）
    sort.Slice(selected, func(i, j int) bool {
        if selected[i].Importance != selected[j].Importance {
            return selected[i].Importance > selected[j].Importance
        }
        if selected[i].WeightedScore != selected[j].WeightedScore {
            return selected[i].WeightedScore > selected[j].WeightedScore
        }
        return selected[i].CreatedAt.After(selected[j].CreatedAt)
    })
    
    return selected, nil
}
```

#### Prune() 修剪策略

```go
func (e *Engine) Prune(ctx context.Context) error {
    if e.store == nil {
        return nil
    }
    
    now := e.clock().UTC()
    
    // 收集待删除项
    type deletion struct {
        id        int64
        sessionID string
        reason    string
    }
    
    var toDelete []deletion
    
    // 遍历所有记忆
    err := e.store.Iterate(ctx, func(rec model.MemoryRecord) error {
        // 策略 1: TTL 过期
        if e.opts.TTL > 0 {
            age := now.Sub(rec.CreatedAt)
            if age > e.opts.TTL {
                toDelete = append(toDelete, deletion{
                    id:        rec.ID,
                    sessionID: rec.SessionID,
                    reason:    "ttl_expired",
                })
                return nil
            }
        }
        
        // 策略 2: 重要性过低
        if rec.Importance < e.opts.MinImportance {
            toDelete = append(toDelete, deletion{
                id:        rec.ID,
                sessionID: rec.SessionID,
                reason:    "low_importance",
            })
            return nil
        }
        
        // 策略 3: 语义重复
        // (在 Store 时已处理)
        
        return nil
    })
    
    if err != nil {
        return err
    }
    
    // 批量删除
    const batchSize = 100
    for i := 0; i < len(toDelete); i += batchSize {
        end := min(i+batchSize, len(toDelete))
        batch := toDelete[i:end]
        
        ids := make([]string, len(batch))
        for j, d := range batch {
            ids[j] = strconv.FormatInt(d.id, 10)
        }
        
        if len(ids) > 0 {
            e.store.DeleteMemory(ctx, batch[0].sessionID, ids)
        }
    }
    
    e.metrics.IncPruned(len(toDelete))
    return nil
}
```

---

## Models 模型层代码分析

### 统一接口设计

```go
type Agent interface {
    Generate(ctx context.Context, prompt string) (any, error)
    GenerateWithFiles(ctx context.Context, prompt string, files []File) (any, error)
}

type File struct {
    Name string   // 文件名
    MIME string   // MIME 类型
    Data []byte   // 文件数据
}
```

### Gemini 实现

```go
type GeminiLLM struct {
    client *genai.Client
    model  *genai.GenerativeModel
    prefix string
}

func NewGeminiLLM(ctx context.Context, modelName, prefix string) (*GeminiLLM, error) {
    apiKey := os.Getenv("GOOGLE_API_KEY")
    if apiKey == "" {
        apiKey = os.Getenv("GEMINI_API_KEY")
    }
    if apiKey == "" {
        return nil, errors.New("GOOGLE_API_KEY or GEMINI_API_KEY required")
    }
    
    client, err := genai.NewClient(ctx, option.WithAPIKey(apiKey))
    if err != nil {
        return nil, err
    }
    
    model := client.GenerativeModel(modelName)
    
    // 配置默认参数
    model.SetTemperature(0.7)
    model.SetTopP(0.9)
    model.SetTopK(40)
    model.SetMaxOutputTokens(8192)
    
    return &GeminiLLM{
        client: client,
        model:  model,
        prefix: prefix,
    }, nil
}

func (g *GeminiLLM) Generate(ctx context.Context, prompt string) (any, error) {
    // 添加前缀
    if g.prefix != "" {
        prompt = g.prefix + "\n\n" + prompt
    }
    
    resp, err := g.model.GenerateContent(ctx, genai.Text(prompt))
    if err != nil {
        return nil, err
    }
    
    // 提取文本
    if len(resp.Candidates) > 0 {
        candidate := resp.Candidates[0]
        if len(candidate.Content.Parts) > 0 {
            return candidate.Content.Parts[0], nil
        }
    }
    
    return "", nil
}

func (g *GeminiLLM) GenerateWithFiles(
    ctx context.Context,
    prompt string,
    files []File,
) (any, error) {
    // 构建多模态输入
    parts := []genai.Part{genai.Text(prompt)}
    
    for _, file := range files {
        // 上传文件
        blob := &genai.Blob{
            MIMEType: file.MIME,
            Data:     file.Data,
        }
        parts = append(parts, blob)
    }
    
    resp, err := g.model.GenerateContent(ctx, parts...)
    if err != nil {
        return nil, err
    }
    
    // 提取响应
    if len(resp.Candidates) > 0 {
        return resp.Candidates[0].Content.Parts[0], nil
    }
    
    return "", nil
}
```

### Cached Model 装饰器

```go
type CachedModel struct {
    inner models.Agent
    cache *cache.LRUCache[string, string]
}

func NewCachedModel(inner models.Agent, cacheSize int) *CachedModel {
    return &CachedModel{
        inner: inner,
        cache: cache.NewLRUCache[string, string](cacheSize),
    }
}

func (c *CachedModel) Generate(ctx context.Context, prompt string) (any, error) {
    // 计算缓存键
    key := hashPrompt(prompt)
    
    // 检查缓存
    if cached, found := c.cache.Get(key); found {
        return cached, nil
    }
    
    // 调用内部模型
    resp, err := c.inner.Generate(ctx, prompt)
    if err != nil {
        return nil, err
    }
    
    // 缓存结果
    respStr := fmt.Sprint(resp)
    c.cache.Put(key, respStr)
    
    return resp, nil
}

func hashPrompt(prompt string) string {
    h := sha256.New()
    h.Write([]byte(prompt))
    return hex.EncodeToString(h.Sum(nil))
}
```

**应用效果**：
- 相同提示词的重复调用 < 1ms
- 减少 API 费用
- 适合测试和开发环境

---

## Tools 工具系统代码分析

### StaticToolCatalog 实现

```go
type StaticToolCatalog struct {
    mu    sync.RWMutex
    tools map[string]Tool       // name -> Tool
    specs map[string]ToolSpec   // name -> Spec
    order []string              // 保持注册顺序
}

func NewStaticToolCatalog(tools []Tool) *StaticToolCatalog {
    catalog := &StaticToolCatalog{
        tools: make(map[string]Tool),
        specs: make(map[string]ToolSpec),
    }
    
    for _, tool := range tools {
        _ = catalog.Register(tool)
    }
    
    return catalog
}

func (c *StaticToolCatalog) Register(tool Tool) error {
    if tool == nil {
        return fmt.Errorf("tool is nil")
    }
    
    spec := tool.Spec()
    key := strings.ToLower(strings.TrimSpace(spec.Name))
    
    if key == "" {
        return fmt.Errorf("tool name is empty")
    }
    
    c.mu.Lock()
    defer c.mu.Unlock()
    
    // 检查重复
    if _, exists := c.tools[key]; exists {
        return fmt.Errorf("tool %s already registered", spec.Name)
    }
    
    // 注册
    c.tools[key] = tool
    c.specs[key] = spec
    c.order = append(c.order, key)
    
    return nil
}

func (c *StaticToolCatalog) Lookup(name string) (Tool, ToolSpec, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    key := strings.ToLower(strings.TrimSpace(name))
    tool, ok := c.tools[key]
    if !ok {
        return nil, ToolSpec{}, false
    }
    
    return tool, c.specs[key], true
}

func (c *StaticToolCatalog) Specs() []ToolSpec {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    // 按注册顺序返回
    specs := make([]ToolSpec, 0, len(c.order))
    for _, key := range c.order {
        specs = append(specs, c.specs[key])
    }
    
    return specs
}
```

**设计特点**：
- **大小写不敏感**：工具名统一小写
- **并发安全**：使用读写锁
- **保序**：维护注册顺序

### UTCP 工具注册

```go
func (a *Agent) RegisterAsUTCPProvider(
    ctx context.Context,
    client utcp.UtcpClientInterface,
    name, description string,
) error {
    
    // 创建 CLI Provider
    provider := &cli.CliProvider{
        Name:        name,
        Description: description,
        Tools: []tools.Tool{
            {
                Name:        name,
                Description: description,
                InputSchema: map[string]any{
                    "type": "object",
                    "properties": map[string]any{
                        "instruction": map[string]any{
                            "type":        "string",
                            "description": "User instruction",
                        },
                        "session_id": map[string]any{
                            "type":        "string",
                            "description": "Optional session ID",
                        },
                    },
                    "required": []string{"instruction"},
                },
            },
        },
    }
    
    // 注册处理函数
    provider.Handler = func(ctx context.Context, toolName string, args map[string]any) (any, error) {
        instruction, _ := args["instruction"].(string)
        sessionID, _ := args["session_id"].(string)
        
        if sessionID == "" {
            sessionID = "default"
        }
        
        // 调用 Agent
        response, err := a.Generate(ctx, sessionID, instruction)
        if err != nil {
            return nil, err
        }
        
        return map[string]any{
            "response":   response,
            "session_id": sessionID,
        }, nil
    }
    
    // 注册到 UTCP 客户端
    return client.RegisterProvider(ctx, provider)
}
```

---

## SubAgents 子智能体代码分析

### Researcher 实现

```go
type Researcher struct {
    model   models.Agent
    persona string
}

func NewResearcher(model models.Agent) *Researcher {
    return &Researcher{
        model:   model,
        persona: "You are a diligent research assistant. Provide structured findings and cite sources when available.",
    }
}

func (r *Researcher) Name() string {
    return "researcher"
}

func (r *Researcher) Description() string {
    return "Synthesizes background information and drafts research summaries."
}

func (r *Researcher) Run(ctx context.Context, input string) (string, error) {
    if r.model == nil {
        return "", fmt.Errorf("researcher subagent missing model")
    }
    
    // 构建专业提示词
    prompt := strings.Builder{}
    prompt.WriteString(r.persona)
    prompt.WriteString("\n\nTask:\n")
    prompt.WriteString(strings.TrimSpace(input))
    prompt.WriteString("\n\nDeliverable: Provide a concise research brief with bullet points and next steps.\n")
    
    // 调用模型
    resp, err := r.model.Generate(ctx, prompt.String())
    if err != nil {
        return "", err
    }
    
    return fmt.Sprint(resp), nil
}
```

---

## 性能优化实现细节

### LRU Cache 实现

```go
type LRUCache[K comparable, V any] struct {
    capacity int
    items    map[K]*list.Element
    order    *list.List  // 双向链表维护访问顺序
    mu       sync.RWMutex
}

type entry[K comparable, V any] struct {
    key   K
    value V
}

func NewLRUCache[K comparable, V any](capacity int) *LRUCache[K, V] {
    return &LRUCache[K, V]{
        capacity: capacity,
        items:    make(map[K]*list.Element),
        order:    list.New(),
    }
}

func (c *LRUCache[K, V]) Get(key K) (V, bool) {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    elem, found := c.items[key]
    if !found {
        var zero V
        return zero, false
    }
    
    // 移到最前面（最近使用）
    c.order.MoveToFront(elem)
    
    return elem.Value.(*entry[K, V]).value, true
}

func (c *LRUCache[K, V]) Put(key K, value V) {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    // 已存在则更新
    if elem, found := c.items[key]; found {
        c.order.MoveToFront(elem)
        elem.Value.(*entry[K, V]).value = value
        return
    }
    
    // 新增
    elem := c.order.PushFront(&entry[K, V]{key, value})
    c.items[key] = elem
    
    // 容量控制
    if c.order.Len() > c.capacity {
        oldest := c.order.Back()
        if oldest != nil {
            c.order.Remove(oldest)
            delete(c.items, oldest.Value.(*entry[K, V]).key)
        }
    }
}
```

**性能特征**：
- `Get`: O(1) 平均时间
- `Put`: O(1) 平均时间
- 基准测试: 184 ns/op

### MIME 规范化缓存

```go
var (
    mimeCache     *cache.LRUCache[string, string]
    mimeCacheOnce sync.Once
)

func normalizeMIME(mime string) string {
    mimeCacheOnce.Do(func() {
        mimeCache = cache.NewLRUCache[string, string](500)
    })
    
    // 检查缓存
    if normalized, found := mimeCache.Get(mime); found {
        return normalized
    }
    
    // 规范化
    normalized := strings.ToLower(strings.TrimSpace(mime))
    
    // 缓存
    mimeCache.Put(mime, normalized)
    
    return normalized
}
```

**性能提升**：
- 无缓存: 850 ns/op
- 有缓存: 65 ns/op
- **提升 13x**

### 预分配缓冲区

```go
// 旧代码（频繁分配）
func buildPrompt(parts ...string) string {
    result := ""
    for _, p := range parts {
        result += p + "\n"
    }
    return result
}

// 优化后（预分配）
func buildPrompt(parts ...string) string {
    // 预估容量
    totalLen := 0
    for _, p := range parts {
        totalLen += len(p) + 1  // +1 for "\n"
    }
    
    var sb strings.Builder
    sb.Grow(totalLen)  // 预分配
    
    for _, p := range parts {
        sb.WriteString(p)
        sb.WriteByte('\n')
    }
    
    return sb.String()
}
```

**效果**：
- 减少 40-60% 内存分配
- 减少 GC 压力

---

## 总结

本文档详细分析了 Go-Agent 各核心模块的代码实现：

✅ **Agent 模块**：完整的对话流程、工具编排、状态持久化  
✅ **ADK 模块**：模块化依赖注入、Provider 模式  
✅ **Memory 模块**：RAG 检索、重要性评分、MMR 去重  
✅ **Models 模块**：统一接口、多提供商支持、缓存装饰器  
✅ **Tools 模块**：工具注册、UTCP 集成、CodeMode  
✅ **SubAgents 模块**：专业化智能体、委派模式  
✅ **性能优化**：LRU 缓存、预分配、MIME 规范化  

每个模块都展现了清晰的设计思路和优秀的工程实践。
